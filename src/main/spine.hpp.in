#pragma once
// Common
#include "main/module.hpp"
#include "main/modulecom.hpp"
// Module Specific
#include <dlfcn.h>
#include <mutex>
#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>
#include <set>

#include <boost/filesystem.hpp>
#include <boost/range/iterator_range_core.hpp>

#include "boost/predef.h"

using namespace zmq;

// A little struct to hold pointers relevant to a module.
typedef struct SpineModule {
	void* module_so;
	Module_ctor* createModule;
	Module_dctor* destroyModule;
	bool moduleLoaded = false;
	string moduleName;
} SpineModule;

namespace cppm {
	class Spine : public Module {
		private:
			#if BOOST_OS_MACOS
				string moduleFileExtension = ".dylib";
			#else
				#if BOOST_OS_WINDOWS
					string moduleFileExtension = ".dll";
				#else // Linux
					string moduleFileExtension = ".so";
				#endif
			#endif

			vector<thread> m_threads;
			mutex _loadedModuleMutex; // Protects loadedModules
			set<string> _loadedModules;

			bool isModuleFile(const string& filename);
			set<string> listModules(const string& directory);
			bool openModuleFile(const string& fileName, SpineModule& spineModule);
			int resolveModuleFunctions(SpineModule& spineModule);
		public:
			Spine();
			~Spine();
			void run();
			bool process_message(const Message& message, CatchState cought, SocketType sockT);
			bool loadModules();
			bool loadModules(const string& directory);
			bool loadModule(const string& filename);
			bool loadConfig(string location);
			bool isModuleLoaded(std::string moduleName);
			const string moduleFileLocation = "@MODULES_LOCATION@";

			void registerModule(const string& name);
			void unregisterModule(const string& name);
	};
}